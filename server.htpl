<#
use HTML::HTPL::Client;
use strict qw(vars subs);
use vars qw($func $params $fn $mod $sub $src $users $key $call $found
        $bin $code @params $res $type);

&rewind;

if ($call =~ /^(.*?)\((.*?)\)$/) {
    $func = lc($1);
    $params = $2;
} else {
    &err("Syntax error");
}

open(C, "server_procs");
while(<C>) {
    chop;
    ($fn, $mod, $sub, $src, $users, $key) = split(/,/);
    if (lc($fn) eq $func) {
        $found = 1;
        last;
    }
}
&err("Illegal function call") unless ($found);
&err("Permission denied") unless (!$users ||
               ${__PACKAGE__ . '::REMOTE_USER'} =~ /^$users$/);

if ($src) {
    my ($srcdate, $moddate);
    $srcdate = (stat($src))[10];
    $moddate = (stat($mod))[10];
    if ($moddate < $srcdate) {
        $bin = $HTML::HTPL::Config::dbgbin;
        $code = system("$bin -t -w -o $mod $src");
        &err("Error when translating module") if ($code);
    }
}

@params = splitline($params);

$@ = undef;
eval qq!require "$mod";!;
&err("Error when loading module: $@") if ($@);

&err("Taint subname: $sub") if ($sub =~ /[^a-zA-Z0-9_]/);

my $coderef;
$@ = undef;
eval "$^H |= 0x200; \$coderef = \\\&$sub";

&err("Function not found: $sub") if ($@ || !eval("*${sub}{CODE}"));

$@ = undef;
eval '$res = &$coderef(@params);';

&err("Runtime error: $@") if ($@);

$type = $RESPONSE_SIMPLE;
if (ref($res)) {
    require FreezeThaw;
    $res = FreezeThaw::freeze($res);
    $type = $RESPONSE_FREEZETHAW;
}

if ($key) {
    require Crypt::Simple;
    $res = Crypt::Simple::encrypt($res, $key);
}

require Compress::Zlib;
my $zcmp = Compress::Zlib::deflateInit();
my $out = $zcmp->deflate($res);
$out .= $zcmp->flush;

if (length($out) < length($res)) {
    $res = $out;
    $type = $RESPONSE_ZLIB . $type;
}

&setmimetype("application/$RESPONSE_PREFIX$type");
&addheader("$VERSION_HEADER: $VERSION");
print $res;
exit;

sub err {
    rewind;
    setmimetype("application/$RESPONSE_PREFIX$RESPONSE_ERROR");
    print shift;
    exit;
}
